# Приложение

Это пустой контейнер некого web-приложения на JavaScript, с некоторыми предварительными настройками и инструкцией по сборке.

# Оглавление

- [О проекте](#о-проекте)
  - [Структура](#структура)
  - [Связь](#связь)
- [Состав](#Состав)
  - [API](#api)
  - [Static Server](#static-server)
  - [Web-приложение](#web-приложение)
  - [Административная панель](#административная-панель)
- [Сборка](#сборка)
  - [GitHub](#github)
  - [GitLab](#gitlab)
  - [Docker](#docker)
  - [Сервер](#сервер)
  - [SSH](#ssh)
- [CI-CD](#ci-cd)
  - [Заливка изменений в ветку разработки](#заливка-изменений-в-ветку-разработки)
  - [Предварительная сборка и тестирование](#предварительная-сборка-и-тестирование)
  - [Получение разрешения на компиляцию](#получение-разрешения-на-компиляцию)
  - [Заливка изменений в ветку продакшн](#заливка-изменений-в-ветку-продакшн)
  - [Работа на сервере](#работа-на-сервере)

# О проекте

## Структура

Мы предполагаем, что ваше приложение будет построено на базе микросервисной архитектуры.

В состав микросервисов будут входить:

- Backend:
  - API,
  - Static Server,
- Frontend:
  - Web-приложение,
  - Административная панель.

Такое приложение имеет ряд преимуществ перед fullstack-приложением.

Во-первых, каждый микросервис можно разрабатывать независимо, на любом удобном языке и фреймворке. Их можно дорабатывать и менять, используя новые технологии. При всем этом, изменение одного сервиса не затронет другие сервисы.

Во-вторых, каждый микросервис можно переиспользовать для других приложений.

В-третьих, приложение можно разделить на еще более слабосвязанные сервисы. Например, из состава приложения можно вынести модуль авторизации в качестве отдельного сервиса, со своим API, базой данных, личным кабинетом и т.д.

[^ к оглавлению](#оглавление)

## Связь

Конечно, микросервисы будут так или иначе связаны друг с другом. Для этого они должны иметь ряд стандартов, которые описывают обмен данными и другие принципы взаимодействия.

Эти стандарты будут поддерживаться интерфейсами.

Но центральной точкой будет служить, конечно, API.

Здесь важно правильно настроить сервер, чтобы он мог развести сервисы не только по разным портам, но и по разным адресам.

[^ к оглавлению](#оглавление)

# Состав

## API

[^ к оглавлению](#оглавление)

## Static Server

[^ к оглавлению](#оглавление)

## Web-приложение

[^ к оглавлению](#оглавление)

## Административная панель

[^ к оглавлению](#оглавление)



# Сборка

## GitHub

[^ к оглавлению](#оглавление)

## GitLab

[^ к оглавлению](#оглавление)

## Docker

[^ к оглавлению](#оглавление)

## Сервер

[^ к оглавлению](#оглавление)

## SSH

[^ к оглавлению](#оглавление)



# CI-CD

CI/CD означает Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка.

В настоящее время эта технология используется для автоматизации сборки приложения.

Современный процесс сборки включает в себя следующие этапы:

- заливка изменений в репозиторий, в ветку разработки,
- предварительная сборка и тестирование,
- получение разрешения на компиляцию,
- слияние изменений в репозиторий, в ветку продакшн,
- обновление исходников на сервере из репозитория, из ветки продакшн,
- сборка и обновление приложения.

Изначально этот процесс велся вручную. Но использование CI/CD позволяет его полностью автоматизировать.

Репозитории GitHub и GitLab имеют для этого встроенные инструменты - GitHub Actions и GitLab CI соответственно.

По-сути, вы просто задаете сценарии проходжения каждого этапа. Сценарии включают в себя команды на запуск скриптов и условия, что и в какой момент выполнять, где проолжить процесс, а где прервать его и т.д.

Каждый сценарий разворачивается в контейнере, это может быть, например, Kubernetes или Docker.

[^ к оглавлению](#оглавление)

## Заливка изменений в ветку разработки

Этот этап является тем действием, которое запускает весь процесс CI/CD.

Подробнее работа с репозиториями GitHub и GitLab описана в соответствующих разделах.

[^ к оглавлению](#оглавление)

## Предварительная сборка и тестирование

Согласно заданному сценарию создается контейнер, куда помещается код из данной ветки репозитория.

Затем начинают выполнятся указанные скрипты.

Обычно это тесты в формате JavaScript.

В случае возникновения ошибок, выполнение всего процесса должно прекратиться.

Вы также можете добавить скрипт, который отправляет уведомление об успешном или неуспешном прохождении данного этапа.

[^ к оглавлению](#оглавление)

## Получение разрешения на компиляцию

Здесь возможны два сценария развития.

Первый скрипт прекращает свое действие. И команда разработки ждет разрешения на компиляцию.

После получения данного разрешения, вручную запускается слияние из ветки разработки в ветку продакшн. И в этот момент срабатывает второй скрипт.

Однако, в большинстве случаев, разрешение - чисто формальная процедура. Подтверждение происходит при успешном прохождении всех тестов.

Поэтому мы не видим смысла останавливаться на данном этапе и в случае успешного тестирования переходить к следующему.

[^ к оглавлению](#оглавление)

## Заливка изменений в ветку продакшн

Иногда бывают такие проекты, которые практически невозможно покрыть тестами на 100%. В добавок к этому, в приложении существует много вещей, относящихся к пользовательскому интерфейсу, которые требуется оценивать чисто визуально и с точки зрения удобства пользования.

В этих случаях лучшим решением будет создание двух продакшн веток - предварительной и релизной.

Соответственно, изменения автоматически будут добавляться в предварительный продакшн. А релиз будет запускаться отдельным скриптом после заливки изменений из предварительной в релизную ветку.

[^ к оглавлению](#оглавление)

## Работа на сервере

Работа на сервере - это отдельный большой этап, который является подготовкой к непосредственно сборке приложения.

Хорошим решением может считаться виртуальный или выделенный сервер. Но при некоторых условиях можно настроить работу и на обычном хостинге.

Для сервера можно настроить работу в docker-контейнере. Это имеет ряд преимуществ, например, вам не нужно заботиться об окружении, дополнительных компонентах, а также совместимости с вашей локальной средой разработки. Однако docker-контейнер будет работать медленно.

С другой стороны, сам сервер придется настроить всего один раз, а работать он будет намного быстрее.

Здесь не имеет смысла останавливаться на настройке сервера. Самое главное, чтобы к нему был разрешен доступ по ssh. Подробнее об этом написано в соответствующем разделе.

Работа скрипта предполагает подключение к серверу по ssh и выполнение определенных команд.

Если вы работаете с docker-контейнером, то вам скорее всего нужно будет заново пересобрать его. Все остальные действия будут произведены скриптами самого docker. Которые вы тоже, безусловно, настроили.

Для чистого сервера вам понадобится обновить код из репозитория и запустить сборку приложения.

Для работы на хостинге вам придется запускать сборку приложения в виртуальном контейнере git, а затем подключаться к хостингу по ssh и вытаскивать файлы прямым копированием.

[^ к оглавлению](#оглавление)
