# CI/CD

Это репозиторий с настройками для запуска CI/CD.

В качестве ресурса используется некое web-приложение на JavaScript.

# Оглавление

- [О проекте](#о-проекте)
  - [Заливка изменений в ветку разработки](#заливка-изменений-в-ветку-разработки)
  - [Предварительная сборка и тестирование](#предварительная-сборка-и-тестирование)
  - [Получение разрешения на компиляцию](#получение-разрешения-на-компиляцию)
  - [Заливка изменений в ветку продакшн](#заливка-изменений-в-ветку-продакшн)
  - [Работа на сервере](#работа-на-сервере)
- [Сборка](#сборка)
  - [GitHub](#github)
  - [GitLab](#gitlab)
  - [Docker](#docker)
  - [Сервер](#сервер)
  - [SSH](#ssh)

# О проекте

CI/CD означает Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка.

В настоящее время эта технология используется для автоматизации сборки приложения.

Современный процесс сборки включает в себя следующие этапы:

- заливка изменений в репозиторий, в ветку разработки,
- предварительная сборка и тестирование,
- получение разрешения на компиляцию,
- слияние изменений в репозиторий, в ветку продакшн,
- обновление исходников на сервере из репозитория, из ветки продакшн,
- сборка и обновление приложения.

Изначально этот процесс велся вручную. Но использование CI/CD позволяет его полностью автоматизировать.

Репозитории GitHub и GitLab имеют для этого встроенные инструменты - GitHub Actions и GitLab CI соответственно.

По-сути, вы просто задаете сценарии проходжения каждого этапа. Сценарии включают в себя команды на запуск скриптов и условия, что и в какой момент выполнять, где проолжить процесс, а где прервать его и т.д.

Каждый сценарий разворачивается в контейнере, это может быть, например, Kubernetes или Docker.

[^ к оглавлению](#оглавление)

## Заливка изменений в ветку разработки

Этот этап является тем действием, которое запускает весь процесс CI/CD.

Подробнее работа с репозиториями GitHub и GitLab описана в соответствующих разделах.

[^ к оглавлению](#оглавление)

## Предварительная сборка и тестирование

Согласно заданному сценарию создается контейнер, куда помещается код из данной ветки репозитория.

Затем начинают выполнятся указанные скрипты.

Обычно это тесты в формате JavaScript.

В случае возникновения ошибок, выполнение всего процесса должно прекратиться.

Вы также можете добавить скрипт, который отправляет уведомление об успешном или неуспешном прохождении данного этапа.

[^ к оглавлению](#оглавление)

## Получение разрешения на компиляцию

Здесь возможны два сценария развития.

Первый скрипт прекращает свое действие. И команда разработки ждет разрешения на компиляцию.

После получения данного разрешения, вручную запускается слияние из ветки разработки в ветку продакшн. И в этот момент срабатывает второй скрипт.

Однако, в большинстве случаев, разрешение - чисто формальная процедура. Подтверждение происходит при успешном прохождении всех тестов.

Поэтому мы не видим смысла останавливаться на данном этапе и в случае успешного тестирования переходить к следующему.

[^ к оглавлению](#оглавление)

## Заливка изменений в ветку продакшн

Иногда бывают такие проекты, которые практически невозможно покрыть тестами на 100%. В добавок к этому, в приложении существует много вещей, относящихся к пользовательскому интерфейсу, которые требуется оценивать чисто визуально и с точки зрения удобства пользования.

В этих случаях лучшим решением будет создание двух продакшн веток - предварительной и релизной.

Соответственно, изменения автоматически будут добавляться в предварительный продакшн. А релиз будет запускаться отдельным скриптом после заливки изменений из предварительной в релизную ветку.

[^ к оглавлению](#оглавление)

## Работа на сервере

Работа на сервере - это отдельный большой этап, который является подготовкой к непосредственно сборке приложения.

Хорошим решением может считаться виртуальный или выделенный сервер. Но при некоторых условиях можно настроить работу и на обычном хостинге.

Для сервера можно настроить работу в docker-контейнере. Это имеет ряд преимуществ, например, вам не нужно заботиться об окружении, дополнительных компонентах, а также совместимости с вашей локальной средой разработки. Однако docker-контейнер будет работать медленно.

С другой стороны, сам сервер придется настроить всего один раз, а работать он будет намного быстрее.

Здесь не имеет смысла останавливаться на настройке сервера. Самое главное, чтобы к нему был разрешен доступ по ssh. Подробнее об этом написано в соответствующем разделе.

Работа скрипта предполагает подключение к серверу по ssh и выполнение определенных команд.

Если вы работаете с docker-контейнером, то вам скорее всего нужно будет заново пересобрать его. Все остальные действия будут произведены скриптами самого docker. Которые вы тоже, безусловно, настроили.

Для чистого сервера вам понадобится обновить код из репозитория и запустить сборку приложения.

Для работы на хостинге вам придется запускать сборку приложения в виртуальном контейнере git, а затем подключаться к хостингу по ssh и вытаскивать файлы прямым копированием.

[^ к оглавлению](#оглавление)

# Сборка

## GitHub

В GitHub есть инструмент Actions, который управляет CI/CD.

Для того, чтобы подключить экшены, нужно создать следующий путь в корневой папке вашего проекта

```
.github\workflows\
```

и добавить туда файл в формате **YAML**, например

```
github-actions-demo.yml
```

GitHub Actions предлагает прекрасный инструмент, который позволяет запустить контейнер на базе **Ubuntu** со множеством предустановленных программ и компонентов.

В самом начале файла мы задаем условия срабатывания экшена.

```
on:
  push:
    branches: [ "production" ]
  pull_request:
    branches: [ "production" ]
```

- **on** — это описание события, по которому будет запускаться наш скрипт,
- **push** — это условие прямого обновления ветки,
- **pull_request** — это условие слияния другой ветки в текущую.

Мы можем указать не одну, а сразу несколько веток. Но мы предлагаем работать с веткой **production**.

Дело в том, что у вас может быть несколько веток. Мастер-ветка **master** или **main** часто используется как текущая ветка разработки. Но даже если вы используете специальную ветку типа **development**, никто не застрахован от случайного обновления мастер ветки.

И тогда непременно запустится скрипт. Даже если он не пройдет проверок, это будет лишняя нагрузка на систему. А если пройдет, это может привести к появлению ненужного в продакшене функционала, который, возможно, еще даже не утвержден.

С другой стороны, ветка типа **development** может использоваться для промежуточного билда, который также использует свои экшены. Но он предназначен для альфа и бета тестирования. Этот билд может располагаться на тестовом сервере, куда обычные пользователи не имеют доступа.

Такое решение нужно для того, чтобы оценить билд визуально, насколько он удобен, насколько качественно реализован с точки зрения UX/UI, насколько соответствует ТЗ - в общем выявить все то, что невозможно покрыть тестами.

- **env** — переменные окружения.

> Также мы можем использовать **env** внутри **steps**.

Так мы можем их задавать:

```
env:
  NAME: "..."
```

Так мы можем их использовать:

```
# bash
run: |
  $NAME
  $(echo $NAME)

# power shell
run: $env:NAME

# cmd
run: %NAME%
```

В GitHub мы можем использовать механизм **secrets**, который позволяет хранить приватные данные в настройках репозитория, отдельно от кодовой базы. Таким образом, они становятся недоступны даже для публичного репозитория.

Добавить переменную можно в настройках репозитория, в разделе **Secrets and variables** / **Actions**. Мы рекомендуем использовать именно **Repository secrets**.

Передать эту переменную в переменную окружения можно так:

```
env:
  NAME: ${{ secrets.NAME }}
```

- **jobs** — описание заданий,
- **runs-on** — контейнер на базе операционной системы (Ubuntu, Windows, Mac OS),
- **steps** — шаги выполнения для каждой задачи.

Внутри шагов есть свои параметры:

- **name** — название шага, которое будет отображаться в логах GitHub Actions,
- **uses** — позволяет переиспользовать другие экшены, зарегистрированные в GitHub,
- **with** — дает нам указать аргументы, которые будут передаваться в экшен,
- **shell** — позволяет нам выбрать терминал или командную строку (например **bash**, **pwsh**, **cmd**).
- **run** — команды командной строки.

Так мы можем использовать одну команду:

```
run: command
```

Если нам нужно использовать несколько команд, мы можем описать их в одну строку:

```
run: command1 && command2
```

Или в несколько строк:

```
run: |
  command1
  command2
```

[^ к оглавлению](#оглавление)

## GitLab

https://habr.com/ru/post/498436/

https://mcs.mail.ru/docs/additionals/cases/cases-gitlab/case-gitlab

https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-gitlab-on-ubuntu-18-04-ru

https://www.dmosk.ru/miniinstruktions.php?mini=gitlab-pipeline

https://doka.guide/tools/gitlab-ci-cd/

[^ к оглавлению](#оглавление)

## Docker

[^ к оглавлению](#оглавление)

## Сервер

[^ к оглавлению](#оглавление)

## SSH

Продолжим конфигурировать наш CI/CD.

В случае использования GitHub Actions у нас уже имеются предустановленный компонент **open-ssh**. Благодаря ему мы можем прямо в контейнере сделать билд и залить его по SSH на наш сервер или даже хостинг.

Доступ по SSH обычно идет по паролю. Но у нас не будет возможности вводить пароль. Поэтому нам нужно воспользоваться компонентом **sshpass**.

Следующая проблема, которая может возникнуть, связана с безопасностью доступа. И здесь есть два варианта:

- задать конфигурацию ssh клиента в файле,
- задать необходимые опции сразу в командной строке.

В данном случае мы пошли вторым путем. Дело в том, что контейнер GitHub запускается только один раз и настраивать его не имеет смысла.

Тем не менее, вы можете подтянуть файл настроек из репозитория и дополнительными командами переместить его в нужное место.

Вот опции, которые нас интересуют:

- CheckHostIP=no - здесь мы отключаем проверки хоста,
- StrictHostKeyChecking=no - здесь мы отключаем жесткие условия проверки,
- UserKnownHostsFile=/dev/null - здесь мы назначаем пустой файл в качестве списка хостов.

Конечно, эти опции делают соединение по **ssh** небезопасным. Однако здесь они вызываются из изолированного контейнера и действуют только на время сборки. Поэтому мы считаем, что в данном случае вопросом слабой безопасности можно пренебречь.

Гораздо важнее информация, которую вы передаете в командах, а именно:

- пароль,
- логин,
- адрес хоста и порт,
- путь к рабочей папке домена.

Эти данные передаются через переменные окружения:

```
SSH_SERVER: "0.0.0.127"
SSH_PORT: "22"
SSH_USER: "..."
SSH_PASSWORD: "..."
SSH_WORKDIR: "/var/..."
WORKDIR: "/home/runner/work/your-app-name/your-app-name/build"
```

Дело в том, что эти данные будут хранится в репозитории. Поэтому ваш репозиторий необходимо делать приватным. Или использовать **секретные переменные**, например так:

```
SSH_SERVER: ${{ secrets.SSH_SERVER }}
```

> Подробнее о механизме секретных переменных смотрите в разделе, посвященном репозиториям.

> Рекомендуем внимательно проверить имя пользователя и пароль и убедиться, что **ssh** подключение проходит стабильно. Желательно отдельно выполнить тестовое подключение до того, как вы приступите к настройке CI/CD.

Вам желательно знать полный путь до рабочей папки вашего проекта **www**, **public_html** или др., в которой должен располагаться исполняемый файл **index.html**, **index.php** или др.

Путь до папки билда будет всегда одинаковый. Он сконфигурирован внутри контейнера. На всякий случай вы можете посмотреть его в логах GitHub Actions, в разделе **Run actions/checkout@v3**.

> Вместо **your-app-name** нужно указать имя вашего репозитория.

Командами **find** и **chmod** мы задаем права для файлов и папок вашего проекта. Иногда это может оказаться очень важным.

Как вариант, вы можете использовать такой порядок:

- копируем билд в папку проекта, названную типа **.../public_html_build**
- подключаемся к серверу по **ssh**

```
sshpass -p $(echo $SSH_PASSWORD) ssh -o CheckHostIP=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $(echo $SSH_PORT) $(echo $SSH_USER)@$(echo $SSH_SERVER)
```

- удаляем старую папку проекта типа **public_html_old**
- переходим в рабочую папку проекта

```
cd $(echo $SSH_WORKDIR)
```

- переименовываем ее, например в **public_html_old**
- переименовываем папку билда **public_html_build** в рабочую **public_html**

Такой подход выгоден по нескольким причинам:

- все файлы проекта будут гарантированно обновлены, не останется старых;
- обновление проекта будет мгновенным и целым, а не постепенным, особенно когда файлов проекта много и они большие по объему;
- в случае возникновения проблем, у вас на сервере будет старый билд.

[^ к оглавлению](#оглавление)
